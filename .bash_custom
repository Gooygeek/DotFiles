######  INIT  ######

shopt -s expand_aliases

# Easy way to reload the Bash Config
alias rebash='source ~/.bashrc'

######  ENV  ######

# env {{{{{{

# Set the default editor to vim.
export EDITOR=vim
export VISUAL=vim

# Set the location of the .inputrc file
#export INPUTRC=~/.inputrc

# Text Colours and Effects
# Effects
RESET_EFFECTS='\[\e[0m\]'
BOLD='\[\e[1m\]'
#BLINK='\[\e[5m\]'
# Normal Colours
BLACK='\[\e[30m\]'
RED='\[\e[31m\]'
GREEN='\[\e[32m\]'
YELLOW='\[\e[33m\]'
BLUE='\[\e[34m\]'
MAGENTA='\[\e[35m\]'
CYAN='\[\e[36m\]'
LIGHTGRAY='\[\e[37m\]'
# Equal to Normal colours with the Bold Effect
DARKGREY='\[\e[90m\]'
LIGHTRED='\[\e[91m\]'
LIGHTGREEN='\[\e[92m\]'
LIGHTYELLOW='\[\e[93m\]'
LIGHTBLUE='\[\e[94m\]'
LIGHTMAGENTA='\[\e[95m\]'
LIGHTCYAN='\[\e[96m\]'
WHITE='\[\e[97m\]'
# }}}}}}

######  MISC. ALIAS  ######

# Aliases {{{

# Easier switch to root
alias sr='sudo su root'

# Allows Aliases to be expanded when using a bare sudo <command>
alias sudo='sudo '

# Curl sends back 3XX errors be default, '-L' means it will automatically follow the redirect.
alias curl='curl -L'

# A bit qucker and easier by to resolve dns names
alias dns='nslookup'

# ensure tmux used 256 colours
alias tmux='tmux -2'
alias t='tmux -2'
alias tn='tmux -2 new -s'
alias ta='tmux -2 a -t'
alias taw='tmux -2 a -t webserver'

# small git shortcut
alias g='git'
alias gitp='git push'
alias gp='git push'
alias gc='gitc'

# Python
if which python3 > /dev/null; then
    alias py='python3'
else
    alias py='python'
fi

# vim
alias v='vim'

# Quick way to make something execuatable
alias exe='chmod u+x'

# Alias's for making archives
alias mktar='tar -cvf'
alias mkbz2='tar -cvjf'
alias mkgz='tar -cvzf'

# Aliases for functions defined below
alias bm='bookmark_manager'
alias cd='changedir'
alias bd='backdir'

# Either start an ssh-agent for every terminal or have a simple command to start it
#SSHAGENT=/usr/bin/ssh-agent
#SSHAGENTARGS="-s"
#if [ -z "$SSH_AUTH_SOCK" -a -x "$SSHAGENT" ]; then
#    eval `$SSHAGENT $SSHAGENTARGS`
#    trap "kill $SSH_AGENT_PID" 0
#fi
alias ssh-start='eval `ssh-agent -s`'

# }}}

######  MISC. FUNCTIONS  ######

# Functions {{{

# Quick way to search for running scripts/apps
psgrep() {
    echo "ps -aux:"
    ps -aux | grep $1 
    echo ""
    echo "top:"
    top -b -n 1 | grep $1
}

# Assume a role/profile and export the creds to environment variables
aws-creds() {
    # awk 1 = The seperator is everything between ']' and '['. Therefore, only what is inside the square brackets are piped on.
    #    This will therefore return a list of 'profile <profile>'. (except the first line, which would be 'default').
    # awk 2 = If the line is greater than 1 (i.e. not the first line), then print the second item.
    #    This therefore prints all and only the roles that can be assumed
    PROFILES=$(awk -F"\\\]|\\\[" '/^\[/{print $2}' ~/.aws/config | awk '{if(NR>1)print $2}')

    # This provides a multiple choice method of selecting a profile.
    #    The role will then be assumed and the resulting creds will be exported to the environment varibles
    select PROFILE in $PROFILES; do
    res=`aws sts assume-role --role-arn $(aws configure get $PROFILE.role_arn) --role-session-name my_profile_session --profile $PROFILE`
    export AWS_ACCESS_KEY_ID=`echo $res | jq -r '.Credentials.AccessKeyId'`
    export AWS_SECRET_ACCESS_KEY=`echo $res | jq -r '.Credentials.SecretAccessKey'`
    export AWS_SESSION_TOKEN=`echo $res | jq -r '.Credentials.SessionToken'`
    export AWS_REGION=`aws configure get region --profile $PROFILE`
    break
done
}

# Make a directory and then change to it.
mcd() {
    mkdir $1
    cd $1
}

# Add and commit (should use vim if used with other dotfiles), changes are shown in the buffer but not added, makes for ealiy seesing what was changed to make better commit messages
gitc() { git add . && git commit --verbose; }

# Bash bookmark manager, credit goes to getmizanur at Stackoverflow
bookmark_manager() {
    bookmark_storage="${HOME}/.bookmarks"
    USAGE="Usage: bm [-c|-g|-d|-l] [bookmark]
      -c | --create <bookmark>
        Bookmark the current directory under <bookmark>
      -g | --go <bookmark>
        Go to the directory saved under <boomark>
      -d | --delete <boomark>
        Delete directory under <bookmark>
      -l | --list
        List all the saved bookmarks

      Anything else shows this help text
    " ;
    if  [ ! -e ${bookmark_storage} ] ; then
        mkdir ${bookmark_storage}
    fi

    case $1 in
        # create bookmark
        -c | --create) shift
            if [ ! -f ${bookmark_storage}/$1 ] ; then
                echo "$(pwd)" > ${bookmark_storage}/"$1" ;
            else
                echo "Try again! Looks like there is already a bookmark '$1'"
            fi
            ;;
        # goto bookmark
        -g | --go) shift
            if [ -f ${bookmark_storage}/${1} ] ; then
                cd $(cat ${bookmark_storage}/${1})
            else
                echo "Mmm...looks like your bookmark has spontaneously combusted. What I mean to say is that your bookmark does not exist." ;
            fi
            ;;
        # delete bookmark
        -d | --delete) shift
            if [ -f ${bookmark_storage}/$1 ] ; then
                rm ${bookmark_storage}/"$1" ;
            else
                echo "Oops, forgot to specify the bookmark" ;
            fi
            ;;
        # list bookmarks
        -l | --list) shift
            for bookmark in ${bookmark_storage}/*
            do
                echo  "$(basename ${bookmark}) -> $(cat ${bookmark})" ;
            done
            ;;
         *) echo "$USAGE" ;
            ;;
    esac
}

# Replacement for when 'tree' is not installed
# The 'find' command can also be used and replaces everything upto and including the first sed operation
simple_tree() {
    HORIZONTAL_CHAR="--";
        ls -AF --format=horizontal --color=auto -AR $1 | grep --color=auto ":$" | sed -e 's/:$//' -e "s/[^-][^\/]*\//$HORIZONTAL_CHAR/g" -e "s/^/ /" -e "s/-/|/"
}

# No need to remember which tool is used to decompress different file types
# Credit goes to zachbrowne on Github
extract () {
	for archive in $*; do
		if [ -f $archive ] ; then
			case $archive in
				*.tar.bz2)   tar xvjf $archive    ;;
				*.tar.gz)    tar xvzf $archive    ;;
				*.bz2)       bunzip2 $archive     || tar xvjf $archive ;;
				*.rar)       rar x $archive       ;;
				*.gz)        gunzip $archive      || tar xvzf $archive ;;
				*.tar)       tar xvf $archive     ;;
				*.tbz2)      tar xvjf $archive    ;;
				*.tgz)       tar xvzf $archive    ;;
				*.zip)       unzip $archive       ;;
				*.Z)         uncompress $archive  ;;
				*.7z)        7z x $archive        ;;
				*)           echo "don't know how to extract '$archive'..." ;;
			esac
		else
			echo "'$archive' is not a valid file!"
		fi
	done
}

# Searches for text in all files in the current folder
ftext ()
{
	# -i case-insensitive
	# -I ignore binary files
	# -H causes filename to be printed
	# -r recursive search
	# -n causes line number to be printed
	# optional: -F treat search term as a literal, not a regular expression
	# optional: -l only print filenames and not the matching lines ex. grep -irl "$1" *
	grep -iIHrnF --color=always "$1" . | less -r
}
# }}}

######  BASH  ######

# Bash {{{

# Autocomplete for bash
if [ -f /etc/bash_completion ]; then
  . /etc/bash_completion
elif [ -f /opt/local/etc/profile.d/bash_completion.sh ]; then
  . /opt/local/etc/profile.d/bash_completion.sh
fi

# Case insensitive when performing filename expansion
shopt -s nocaseglob

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# History expansion takes place after a space rather than on command execution
bind '" ":magic-space'

# Multi-line commands are saved to the history with embedded newlines rather than using semicolon separators where possible
shopt -s lithist

# Don't put duplicate lines in the history and do not add lines that start with a space
export HISTCONTROL=erasedups:ignoredups:ignorespace

# Don't add to the history The commands (match exactly):
# 	- &
# 	- ls
# 	- fg
# 	- bg
# 	- exit
# 	- [Starts with a space]
# 	- [Starts with a tab]
export HISTIGNORE="&:ls:[bf]g:exit:[ \t]*"

# Large History size
export HISTSIZE=99999

# Append commands to the bash command history file (~/.bash_history) instead of overwriting it.
shopt -s histappend

# Append commands to the history every time a prompt is shown, instead of after closing the session.
PROMPT_COMMAND='history -a'

# Better prompt (with git support)
export GIT_PS1_SHOWDIRTYSTATE=true
export export GIT_PS1_SHOWSTASHSTATE=true
declare -F | grep __git_ps1 > /dev/null
if [ "$?" -eq 0 ]; then
  export PS1=" \n\u:${LIGHTBLUE}[\w]${LIGHTRED}\$(__git_ps1 '(%s)') ${LIGHTGREEN}ʃ${RESET_EFFECTS} "
else
  export PS1=" \n\u:${LIGHTBLUE}[\w] ${GREEN}${BOLD}ʃ${RESET_EFFECTS} "
fi

# Multiline promt
export PS2="» "
# Potential prompt symbols
# $
# §
# ¦
# ¬
# ʃ
# ˧
# »

# }}}

######  CD  ######

# cd {{{

# If set, minor errors in the spelling of a directory component in a cd command will be corrected. The errors checked for are transposed characters, a missing character, and a character too many. If a correction is found, the corrected path is printed, and the command proceeds.
shopt -s cdspell

# Tab-completion only shows directories
complete -d cd

# Moves up a specified number of directories
cdup() { cd $(eval printf '../'%.0s {1..$1}) && pwd; }

# CDPATH is like the path for cd directories. Default is just '.'
export CDPATH=.:~

# Keep a history of the directories navigated to
changedir() {
  if [ "$#" = "0" ]; then
  pushd ${HOME} > /dev/null
  elif [ -f "${1}" ]; then
    ${EDITOR} ${1}
  else
    pushd "$1" > /dev/null
  fi
}

# Go back to the previous directory in the nav history.
# Can also accept a number and will go back that many times
backdir() {
  if [ "$#" = "0" ]; then
    popd > /dev/null
  else
    for i in $(seq ${1}); do
      popd > /dev/null
    done
  fi
}

# List directory navigation history with numbers
# This makes it easy to enter a number in bd to go back to that dir
alias dh='dirs -v'

# }}}

######  ls  ######

# ls {{{

# List dir with:
# 	- Almost all
# 	- Colour
# 	- Filetype
# 	- Horizonal
alias ls='ls -AF --format=horizontal --color=auto'

# List dir with:
# 	- Long format
# 	- Almost all
# 	- Sorted by time (recents at the bottom)
# 	- Human readable filesize
# 	- Nicer timestamp
alias lls='ls -AFltrh --time-style long-iso --color=auto'

# }}}

######  vi  ######

# vi {{{

# Save a copy of the file before oopening it in vi
function safevi() {
  cp  ${1} ${1}.$(date +"%Y%m%d-%H%M%S")
  vi ${1}
}
# }}}

######  OTHER  ######

# Other {{{

# 'ESC+.' will insert the last commands last argument. Same as 'ALT+.'. Looks to be the same as what '!$' is expanded to
bind '"\e.": yank-last-arg'

# Make sure left and right arrow keys work correctly (default)
bind '"\e[C": forward-char'
bind '"\e[D": backward-char'

# Up and Down arrow will search the history, filtering on the command currently typed
bind '"\e[A":history-search-backward'
bind '"\e[B":history-search-forward'

# SHIFT+TAB will cycle through tab completion options
bind '"\e[Z":menu-complete'

# Redirect '>' will not overwrite existing files
# Can be forced with '>!'
set -o noclobber

# When tab-completing, tab will complete until the ambiguity. Often an additional tab is required to then show the possibilities. This setting means it will show the possibilities immediately. (Not woorking)
#bind "set show-all-if-ambiguous on"

# Disable the auditory tone aka bell
bind "set bell-style visible"
bind "set prefer-visible-bell"

# Disable XON/XOFF control flow i.e. Ctrl-s wont hang the terminal (if it does, use Ctrl-q to resume)
stty -ixon

# Adopt new push behaviour and don't show message about it not being set
git config --global push.default simple

# Check the window size after each command and, if necessary,
#   update the values of LINES and COLUMNS.
shopt -s checkwinsize

# }}}


# OPTIONAL

# Awesome command prompt
# . ~/.bash_prompt_advanced

# Short Prompt
# . ~/.bash_prompt_short

######  TEST SECTION  ######


# config for this file only
# vim:foldmethod=marker:foldlevel=0:foldminlines=0
