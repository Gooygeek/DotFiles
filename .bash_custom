######  INIT  ######

shopt -s expand_aliases

######  ENV  ######

# env {{{{{{

# Set the default editor to vim.
export EDITOR=vim
export VISUAL=vim

# Set the location of the .inputrc file
export INPUTRC=~/.inputrc

# Text Colours and Effects
# Effects
RESET_EFFECTS='\e[0m'
BOLD='\e[1m'
BLINK='\e[5m'
# Normal Colours
BLACK='\e[30m'
RED='\e[31m'
GREEN='\e[32m'
YELLOW='\e[33m'
BLUE='\e[34m'
MAGENTA='\e[35m'
CYAN='\e[36m'
LIGHTGRAY='\e[37m'
# Equal to Normal colours with the Bold Effect
DARKGREY='\e[90m'
LIGHTRED='\e[91m'
LIGHTGREEN='\e[92m'
LIGHTYELLOW='\e[93m'
LIGHTBLUE='\e[94m'
LIGHTMAGENTA='\e[95m'
LIGHTCYAN='\e[96m'
WHITE='\e[97m'

# }}}}}}

######  MISC. ALIAS  ######

# Aliases {{{

# Easier switch to root
alias sr='sudo su root'

# Allows Aliases to be expanded when using a bare sudo <command>
alias sudo='sudo '

# ensure tmux used 256 colours
alias tmux='tmux -2'
alias t='tmux -2'
alias tn='tmux -2 new -s'
alias ta='tmux -2 a -t'
alias taw='tmux -2 a -t webserver'

# small git shortcut
alias g='git'
alias gitp='git push'
alias gp='git push'
alias gc='gitc'

# vim
alias v='vim'

# Quick way to make something execuatable
alias exe='chmod u+x'

# Aliases for functions defined below
alias bm='bookmark_manager'
alias cd='changedir'
alias bd='backdir'

# }}}

######  MISC. FUNCTIONS  ######

# Functions {{{

# Add and commit (should use vim if used with other dotfiles), changes are shown in the buffer but not added, makes for ealiy seesing what was changed to make better commit messages
gitc() { git add . && git commit --verbose; }

# Bash bookmark manager, credit goes to getmizanur at Stackoverflow
bookmark_manager() {
    bookmark_storage="${HOME}/.bookmarks"
    USAGE="Usage: bm [-c|-g|-d|-l] [bookmark]
      -c | --create <bookmark>
        Bookmark the current directory under <bookmark>
      -g | --go <bookmark>
        Go to the directory saved under <boomark>
      -d | --delete <boomark>
        Delete directory under <bookmark>
      -l | --list
        List all the saved bookmarks

      Anything else shows this help text
    " ;
    if  [ ! -e ${bookmark_storage} ] ; then
        mkdir ${bookmark_storage}
    fi

    case $1 in
        # create bookmark
        -c | --create) shift
            if [ ! -f ${bookmark_storage}/$1 ] ; then
                echo "$(pwd)" > ${bookmark_storage}/"$1" ;
            else
                echo "Try again! Looks like there is already a bookmark '$1'"
            fi
            ;;
        # goto bookmark
        -g | --go) shift
            if [ -f ${bookmark_storage}/${1} ] ; then
                cd $(cat ${bookmark_storage}/${1})
            else
                echo "Mmm...looks like your bookmark has spontaneously combusted. What I mean to say is that your bookmark does not exist." ;
            fi
            ;;
        # delete bookmark
        -d | --delete) shift
            if [ -f ${bookmark_storage}/$1 ] ; then
                rm ${bookmark_storage}/"$1" ;
            else
                echo "Oops, forgot to specify the bookmark" ;
            fi
            ;;
        # list bookmarks
        -l | --list) shift
            for bookmark in ${bookmark_storage}/*
            do
                echo  "$(basename ${bookmark}) -> $(cat ${bookmark})" ;
            done
            ;;
         *) echo "$USAGE" ;
            ;;
    esac
}

# Replacement for when 'tree' is not installed
# The 'find' command can also be used and replaces everything upto and including the first sed operation
simple_tree ()
{
    HORIZONTAL_CHAR="--";
        ls -AF --format=horizontal --color=auto -AR $1 | grep --color=auto ":$" | sed -e 's/:$//' -e "s/[^-][^\/]*\//$HORIZONTAL_CHAR/g" -e "s/^/ /" -e "s/-/|/"
}


# }}}

######  BASH  ######

# Bash {{{

# Easy way to reload the Bash Config
alias rebash='source ~/.bashrc'

# Autocomplete for bash
if [ -f /etc/bash_completion ]; then
  . /etc/bash_completion
elif [ -f /opt/local/etc/profile.d/bash_completion.sh ]; then
  . /opt/local/etc/profile.d/bash_completion.sh
fi

# Case insensitive when performing filename expansion
shopt -s nocaseglob

# History expansion takes place after a space rather than on command execution
bind '" ":magic-space'

# Multi-line commands are saved to the history with embedded newlines rather than using semicolon separators where possible
shopt -s lithist

# Avoid succesive duplicates in the bash command history.
export HISTCONTROL=ignoredups

# Don't add to the history The commands (match exactly):
# 	- &
# 	- ls
# 	- fg
# 	- bg
# 	- exit
# 	- [Starts with a space]
# 	- [Starts with a tab]
export HISTIGNORE="&:ls:[bf]g:exit:[ \t]*"

# Large History size
export HISTSIZE=99999

# Append commands to the bash command history file (~/.bash_history) instead of overwriting it.
shopt -s histappend

# Append commands to the history every time a prompt is shown, instead of after closing the session.
PROMPT_COMMAND='history -a'

# Better prompt (with git support)
export GIT_PS1_SHOWDIRTYSTATE=true
export export GIT_PS1_SHOWSTASHSTATE=true
declare -F | grep __git_ps1 > /dev/null
if [ "$?" -eq 0 ]; then
  export PS1="\n\u:${LIGHTBLUE}[\w]${LIGHTRED}\$(__git_ps1 '(%s)') ${LIGHTGREEN}${BLINK}ʃ${RESET_EFFECTS} "
else
  export PS1="\n\u:${LIGHTBLUE}[\w] ${GREEN}${BOLD}${BLINK}ʃ${RESET_EFFECTS} "
fi

# Multiline promt
export PS2="» "
# Potential prompt symbols
# $
# §
# ¦
# ¬
# ʃ
# ˧
# »

# }}}

######  CD  ######

# cd {{{

# If set, minor errors in the spelling of a directory component in a cd command will be corrected. The errors checked for are transposed characters, a missing character, and a character too many. If a correction is found, the corrected path is printed, and the command proceeds.
shopt -s cdspell

# Tab-completion only shows directories
complete -d cd

# Moves up a specified number of directories
cdup() { cd $(eval printf '../'%.0s {1..$1}) && pwd; }

# CDPATH is like the path for cd directories. Default is just '.'
export CDPATH=.:~

# Keep a history of the directories navigated to
changedir() {
  if [ "$#" = "0" ]; then
  pushd ${HOME} > /dev/null
  elif [ -f "${1}" ]; then
    ${EDITOR} ${1}
  else
    pushd "$1" > /dev/null
  fi
}

# Go back to the previous directory in the nav history.
# Can also accept a number and will go back that many times
backdir() {
  if [ "$#" = "0" ]; then
    popd > /dev/null
  else
    for i in $(seq ${1}); do
      popd > /dev/null
    done
  fi
}

# List directory navigation history with numbers
# This makes it easy to enter a number in bd to go back to that dir
alias dh='dirs -v'

# }}}

######  ls  ######

# ls {{{

# List dir with:
# 	- Almost all
# 	- Colour
# 	- Filetype
# 	- Horizonal
alias ls='ls -AF --format=horizontal --color=auto'

# List dir with:
# 	- Long format
# 	- Almost all
# 	- Sorted by time (recents at the bottom)
# 	- Human readable filesize
# 	- Nicer timestamp
alias lls='ls -AFltrh --time-style long-iso --color=auto'

# }}}

######  vi  ######

# vi {{{

# Save a copy of the file before oopening it in vi
function safevi() {
  cp  ${1} ${1}.$(date +"%Y%m%d-%H%M%S")
  vi ${1}
}
# }}}



######  OTHER  ######

# Other {{{

# 'ESC+.' will insert the last commands last argument. Same as 'ALT+.'. Looks to be the same as what '!$' is expanded to
bind '"\e.": yank-last-arg'

# Make sure left and right arrow keys work correctly (default)
bind '"\e[C": forward-char'
bind '"\e[D": backward-char'

# Up and Down arrow will search the history, filtering on the command currently typed
bind '"\e[A":history-search-backward'
bind '"\e[B":history-search-forward'

# SHIFT+TAB will cycle through tab completion options
bind '"\e[Z":menu-complete'

# When tab-completing, tab will complete until the ambiguity. Often an additional tab is required to then show the possibilities. This setting means it will show the possibilities immediately. (Not woorking)
#set show-all-if-ambiguous on

# Disable XON/XOFF control flow i.e. Ctrl-s wont hang the terminal (if it does, use Ctrl-q to resume)
stty -ixon

# Adopt new push behaviour and don't show message about it not being set
git config --global push.default simple


# Either start an ssh-agent for every terminal or have a simple command to start it
#SSHAGENT=/usr/bin/ssh-agent
#SSHAGENTARGS="-s"
#if [ -z "$SSH_AUTH_SOCK" -a -x "$SSHAGENT" ]; then
#    eval `$SSHAGENT $SSHAGENTARGS`
#    trap "kill $SSH_AGENT_PID" 0
#fi
alias ssh-start='eval `ssh-agent -s`'

# }}}

# config for this file only
# vim:foldmethod=marker:foldlevel=0:foldminlines=0
